<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
    <title>Куля Пророцтв</title>

    <!-- 1. Спочатку завантажуємо Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.min.js"></script>

    <!-- 2. Потім MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <!-- Український шрифт -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@700;900&display=swap&subset=cyrillic,cyrillic-ext" rel="stylesheet">

    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#000;overflow:hidden;touch-action:none;font-family:'Roboto',sans-serif;color:#fff}
        #cameraView{position:fixed;top:0;left:0;width:100%;height:100%;object-fit:cover;z-index:1}
        #canvas3d{position:fixed;top:0;left:0;width:100%;height:100%;z-index:2}
        .info-panel{position:absolute;top:15px;left:15px;z-index:100;background:rgba(0,0,0,0.85);padding:12px 18px;border-radius:12px;border:2px solid #8a2be2;backdrop-filter:blur(8px)}
        .timer{position:absolute;top:20px;right:20px;font-size:60px;font-weight:900;color:#00ff00;text-shadow:0 0 20px #00ff00;z-index:100;opacity:0}
        .instructions{position:absolute;bottom:20px;left:0;right:0;text-align:center;z-index:100;background:rgba(0,0,0,0.75);padding:15px;backdrop-filter:blur(6px)}
        .hand-guide{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.95);padding:30px;border-radius:20px;border:3px solid #00ffaa;text-align:center;z-index:100;transition:opacity .5s}
        .loading{position:fixed;inset:0;background:#000;display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:2000;transition:opacity 1s}
        .spinner{width:60px;height:60px;border:6px solid #8a2be233;border-top-color:#8a2be2;border-radius:50%;animation:s 1s linear infinite;margin-bottom:20px}
        @keyframes s{to{transform:rotate(360deg)}}
        .tap{position:absolute;bottom:120px;left:50%;transform:translateX(-50%);background:rgba(0,255,255,0.2);color:#00ffff;padding:16px 32px;border-radius:50px;font-size:18px;font-weight:bold;z-index:10000;backdrop-filter:blur(10px);border:2px solid #00ffff;opacity:0;transition:opacity .5s}
    </style>
</head>
<body>

<div class="loading" id="loading">
    <div class="spinner"></div>
    <div style="font-size:22px">Куля Пророцтв</div>
    <div style="font-size:16px;color:#aaa;margin-top:10px">Завантаження...</div>
</div>

<div class="hand-guide" id="guide">
    <div style="font-size:70px">Palm Up</div>
    <div style="font-size:22px;color:#00ffaa;margin:15px 0">Покажіть долоню задній камері</div>
    <div style="color:#ccc">Утримуйте палець на кулі 3 секунди</div>
</div>

<div class="info-panel">
    <div style="font-size:20px;color:#ffcc00">Куля Пророцтв</div>
    <div style="margin-top:6px">Отримано: <span id="count" style="color:#00ffaa;font-weight:bold">0</span></div>
</div>

<div class="timer" id="timer">3</div>
<div class="instructions">Утримуйте палець на кулі 3 секунди</div>
<div class="tap" id="tapMsg">Торкніться екрану, щоб продовжити</div>

<video id="cameraView" autoplay playsinline muted></video>
<canvas id="canvas3d"></canvas>

<script>
    // === ВСІ ФУНКЦІЇ ВСЕРЕДИНІ, щоб THREE точно був ===
    (function () {
        if (typeof THREE === 'undefined') {
            alert('Помилка завантаження Three.js. Оновіть сторінку.');
            return;
        }

        const CONFIG = {
            SPHERE_RADIUS: 0.05,
            TOUCH_DISTANCE: 0.13,
            HOLD_TIME: 3000,
            TEXT_SCALE: 3.3
        };

        const PROPHECIES = [
            "ВСЕ БУДЕ УКРАЇНА","ТИ СИЛЬНІШИЙ","МИР НЕЗАБАРОМ","МРІЯ ЗБУДЕТЬСЯ",
            "ЛЮБОВ ПОРУЧ","ЗДОРОВ'Я ПОВЕРНЕТЬСЯ","УСПІХ ЧЕКАЄ","ПЕРЕМОГА БЛИЗЬКО"
        ];

        let scene, camera, renderer, sphere, ring;
        let hands, video = document.getElementById('cameraView');
        let handDetected = false, isHolding = false, holdStart = 0, prophecyCount = 0;
        let activeText = null, isProphecyActive = false;

        const el = {
            loading: document.getElementById('loading'),
            guide: document.getElementById('guide'),
            timer: document.getElementById('timer'),
            count: document.getElementById('count'),
            tapMsg: document.getElementById('tapMsg')
        };

        function initThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.01, 10);
            camera.position.z = 0.01;

            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas3d'), alpha: true, antialias: true });
            renderer.setSize(innerWidth, innerHeight);
            renderer.setPixelRatio(Math.min(devicePixelRatio, 2));

            const light = new THREE.PointLight(0x8a2be2, 2, 3);
            light.position.set(0, 1, 1);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));

            // Куля
            const geo = new THREE.SphereGeometry(CONFIG.SPHERE_RADIUS, 64, 64);
            const mat = new THREE.MeshPhongMaterial({color:0x4a00e0, emissive:0x8a2be2, shininess:100, transparent:true, opacity:0.92});
            sphere = new THREE.Mesh(geo, mat);
            sphere.position.z = -0.35;
            scene.add(sphere);

            // Кільце
            const rg = new THREE.RingGeometry(CONFIG.SPHERE_RADIUS*1.3, CONFIG.SPHERE_RADIUS*1.6, 48);
            const rm = new THREE.MeshBasicMaterial({color:0x00ffff, transparent:true, opacity:0.4});
            ring = new THREE.Mesh(rg, rm);
            ring.rotation.x = -Math.PI/2;
            sphere.add(ring);

            createTexts();
            animate();

            setTimeout(() => {
                el.loading.style.opacity = '0';
                setTimeout(() => el.loading.style.display = 'none', 1000);
            }, 1000);
        }

        function createTexts() {
            const radius = CONFIG.SPHERE_RADIUS * 2.8;
            const colors = [0x00ffff,0xff00ff,0xffff00,0x00ff00,0xff6600,0xff3366,0x33ff99,0xffcc00];

            PROPHECIES.forEach((txt,i) => {
                const cv = document.createElement('canvas');
                cv.width = 1024; cv.height = 256;
                const ctx = cv.getContext('2d');
                ctx.font = 'bold 92px "Roboto", sans-serif';
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.strokeStyle = '#000'; ctx.lineWidth = 18;
                ctx.strokeText(txt, 512, 128);
                ctx.fillStyle = '#'+colors[i].toString(16).padStart(6,'0');
                ctx.fillText(txt, 512, 128);

                const tex = new THREE.CanvasTexture(cv);
                const mat = new THREE.MeshBasicMaterial({map:tex, transparent:true, side:THREE.DoubleSide});
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(0.28,0.07), mat);

                const angle = (i/PROPHECIES.length)*Math.PI*2;
                mesh.userData = {baseAngle:angle, radius};
                mesh.position.x = Math.sin(angle)*radius;
                mesh.position.z = Math.cos(angle)*radius;
                mesh.lookAt(sphere.position);
                scene.add(mesh);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            if (!isProphecyActive) {
                sphere.rotation.y += 0.015;
                scene.children.forEach(o => {
                    if (o.userData.radius && o!==activeText) {
                        const t = Date.now()*0.0008;
                        const a = o.userData.baseAngle + t;
                        o.position.x = Math.sin(a)*o.userData.radius + sphere.position.x;
                        o.position.z = Math.cos(a)*o.userData.radius + sphere.position.z;
                        o.position.y = sphere.position.y + Math.sin(t*3+o.userData.baseAngle)*0.03;
                        o.lookAt(sphere.position);
                    }
                });
            }
            renderer.render(scene, camera);
        }

        function onResults(results) {
            if (!results.multiHandLandmarks?.[0]) {
                if (handDetected) { el.guide.style.opacity='1'; handDetected=false; }
                isHolding = false; ring.material.opacity = 0.4;
                return;
            }

            if (!handDetected) { handDetected=true; el.guide.style.opacity='0'; setTimeout(()=>el.guide.style.display='none',600); }

            const l = results.multiHandLandmarks[0];
            const palmX = (l[0].x + l[9].x)/2;
            const palmY = (l[0].y + l[9].y)/2;

            sphere.position.x += ((palmX-0.5)*0.8 - sphere.position.x)*0.15;
            sphere.position.y += ((0.5-palmY)*0.6 - sphere.position.y + 0.12)*0.15;

            const dist = Math.hypot((l[8].x-0.5)*0.8 - sphere.position.x, (0.5-l[8].y)*0.6 - sphere.position.y + 0.12);

            if (dist < CONFIG.TOUCH_DISTANCE && !isProphecyActive) {
                if (!isHolding) { isHolding=true; holdStart=Date.now(); }
                const prog = Math.min((Date.now()-holdStart)/CONFIG.HOLD_TIME, 1);
                ring.scale.set(1+prog*0.5,1+prog*0.5,1);
                ring.material.opacity = 0.8 + prog*0.2;
                if (prog>=1) triggerProphecy();
            } else {
                isHolding=false;
                ring.scale.set(1,1,1);
                ring.material.opacity = 0.4;
            }
        }

        function triggerProphecy() {
            if (isProphecyActive) return;
            isProphecyActive = true;
            if (navigator.vibrate) navigator.vibrate([200,100,200]);

            const texts = scene.children.filter(o=>o.userData.radius);
            activeText = texts[Math.floor(Math.random()*texts.length)];

            activeText.position.set(0, 0.12, -0.45);
            activeText.lookAt(0, 0.15, 0);
            activeText.scale.set(0.01,0.01,0.01);

            prophecyCount++;
            el.count.textContent = prophecyCount;

            const start = performance.now();
            function grow(t) {
                const p = Math.min((t-start)/700,1);
                const ease = p<0.5 ? 4*p*p*p : 1-Math.pow(-2*p+2,3)/2;
                activeText.scale.set(ease*CONFIG.TEXT_SCALE, ease*CONFIG.TEXT_SCALE, ease*CONFIG.TEXT_SCALE);
                if (p<1) requestAnimationFrame(grow);
                else setTimeout(showTap, 600);
            }
            requestAnimationFrame(grow);
        }

        function showTap() {
            el.tapMsg.style.opacity = '1';
            const cont = () => {
                el.tapMsg.style.opacity = '0';
                document.getElementById('canvas3d').removeEventListener('click', cont);
                document.getElementById('canvas3d').removeEventListener('touchstart', cont);

                const orig = {
                    x: Math.sin(activeText.userData.baseAngle)*activeText.userData.radius,
                    z: Math.cos(activeText.userData.baseAngle)*activeText.userData.radius
                };
                const start = performance.now();
                function shrink(t) {
                    const p = Math.min((t-start)/800,1);
                    const ease = 1-Math.pow(1-p,3);
                    const sc = CONFIG.TEXT_SCALE + (0.8-CONFIG.TEXT_SCALE)*ease;
                    activeText.scale.set(sc,sc,sc);
                    activeText.position.x = THREE.MathUtils.lerp(0, orig.x + sphere.position.x, ease);
                    activeText.position.y = THREE.MathUtils.lerp(0.12, sphere.position.y, ease);
                    activeText.position.z = THREE.MathUtils.lerp(-0.45, orig.z + sphere.position.z, ease);
                    if (p<1) requestAnimationFrame(shrink);
                    else { activeText=null; isProphecyActive=false; }
                }
                requestAnimationFrame(shrink);
            };
            document.getElementById('canvas3d').addEventListener('click', cont);
            document.getElementById('canvas3d').addEventListener('touchstart', cont);
        }

        // === ЗАПУСК ===
        window.addEventListener('load', async () => {
            initThreeJS();

            hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
            hands.setOptions({maxNumHands:1, modelComplexity:1, minDetectionConfidence:0.7, minTrackingConfidence:0.7});
            hands.onResults(onResults);

            const camera = new Camera(video, {
                onFrame: async () => await hands.send({image: video}),
                width: 1280, height: 720
            });
            await camera.start();
        });

        window.addEventListener('resize', () => {
            camera.aspect = innerWidth/innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        });
    })();
</script>
</body>
</html>
