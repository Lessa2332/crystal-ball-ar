<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>‚ùÑÔ∏è –°–Ω—ñ–≥–æ–≤–∞ –ö—É–ª—è –ü—Ä–æ—Ä–æ—Ü—Ç–≤</title>
   
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
   
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #0a2e5c 0%, #1a4b8c 50%, #2c3e50 100%);
            color: white;
            height: 100vh; width: 100vw; overflow: hidden;
            touch-action: none; user-select: none;
        }
        #cameraView {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; transform: scaleX(-1); z-index: 1; opacity: 0.35;
        }
        #canvas3d {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 2; pointer-events: none;
        }
        .info-panel {
            position: absolute; top: 15px; left: 15px; z-index: 1000;
            background: rgba(255,255,255,0.15); padding: 12px; border-radius: 15px;
            border: 2px solid rgba(173,216,230,0.5); max-width: 280px;
            backdrop-filter: blur(15px);
        }
        .timer {
            position: absolute; top: 15px; right: 15px; z-index: 1000;
            font-size: 56px; color: #4fc3f7; text-shadow: 0 0 20px #4fc3f7;
            opacity: 0; font-weight: bold;
        }
        .hand-guide {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
            z-index: 3; text-align: center; background: rgba(255,255,255,0.95);
            padding: 25px; border-radius: 20px; border: 3px solid #4fc3f7;
            color: #1565c0; min-width: 280px; box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        .loading {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #0a2e5c 0%, #1a4b8c 100%);
            display: flex; justify-content: center; align-items: center;
            z-index: 2000; font-size: 28px; color: white;
        }
        .instructions {
            position: absolute; bottom: 20px; left: 0; right: 0;
            text-align: center; z-index: 1000; background: rgba(0,30,60,0.8);
            padding: 15px; border-top: 3px solid #4fc3f7; font-size: 16px;
            backdrop-filter: blur(10px);
        }
        @keyframes pulse { 0%,100% { transform: scale(1); } 50% { transform: scale(1.15); } }
    </style>
</head>
<body>
    <div class="loading" id="loadingScreen">
        <div style="text-align:center">
            <div style="font-size:70px;margin-bottom:20px;">‚ùÑÔ∏è</div>
            <div style="font-size:28px;">–°–Ω—ñ–≥–æ–≤–∞ –ö—É–ª—è –ü—Ä–æ—Ä–æ—Ü—Ç–≤</div>
            <div style="color:#b3e5fc;margin-top:10px;">–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...</div>
        </div>
    </div>

    <div class="hand-guide" id="handGuide">
        <div style="font-size:70px;margin-bottom:15px;">Palm</div>
        <div style="font-size:22px;color:#1565c0;">–ü–æ–∫–∞–∂—ñ—Ç—å –¥–æ–ª–æ–Ω—é –∫–∞–º–µ—Ä—ñ</div>
        <div style="color:#546e7a;">–¢–æ—Ä–∫–Ω—ñ—Ç—å—Å—è –∫—É–ª—ñ –Ω–∞ 3 —Å–µ–∫—É–Ω–¥–∏</div>
    </div>

    <div class="info-panel">
        <h1 style="color:#4fc3f7;font-size:22px;">‚ùÑÔ∏è –°–ù–Ü–ì–û–í–ê –ö–£–õ–Ø</h1>
        <p style="font-size:16px;color:#e3f2fd;">–¢–æ—Ä–∫–Ω—ñ—Ç—å—Å—è —Å–Ω—ñ–≥–æ–≤–æ—ó –∫—É–ª—ñ –ø–∞–ª—å—Ü–µ–º</p>
        <p style="margin-top:10px;color:#4fc3f7;font-size:18px;">
            –ü—Ä–æ—Ä–æ—Ü—Ç–≤–∞: <span id="prophecyCount">0</span>
        </p>
    </div>

    <div class="timer" id="timer">3</div>

    <div class="instructions">
        ‚ùÑÔ∏è –°–Ω—ñ–≥–æ–≤–∞ –º–∞–≥—ñ—è ‚Ä¢ –ü–∞–ª–µ—Ü—å –¢–æ—Ä–∫–Ω—ñ—Ç—å—Å—è –Ω–∞ 3 —Å–µ–∫—É–Ω–¥–∏ ‚Ä¢ –†—ñ–∑–¥–≤—è–Ω–µ –ø—Ä–æ—Ä–æ—Ü—Ç–≤–æ
    </div>

    <video id="cameraView" autoplay playsinline></video>
    <canvas id="canvas3d"></canvas>

    <script>
        const CONFIG = {
            COUNTDOWN_TIME: 3,
            PROPHECY_TIME: 5.5,
            SPHERE_RADIUS: 0.25,
            TOUCH_DISTANCE: 0.42,
            TEXT_SCALE_MULTIPLIER: 3.2
        };

        const PROPHECIES = [
            "–ú–∏—Ä —É –≤–∞—à–æ–º—É –¥–æ–º—ñ! ‚ùÑÔ∏è","–†–∞–¥—ñ—Å—Ç—å —É —Å–µ—Ä—Ü—ñ! ‚ú®","–õ—é–±–æ–≤ –∑–∞–≤–∂–¥–∏ –ø–æ—Ä—è–¥! üíô",
            "–ó–¥–æ—Ä–æ–≤'—è –º—ñ—Ü–Ω—ñ—î! üåü","–©–∞—Å—Ç—è –ø—Ä–∏—Ö–æ–¥–∏—Ç—å! üéÑ","–ú—Ä—ñ—ó –∑–±—É–≤–∞—é—Ç—å—Å—è! üåå",
            "–£—Å–ø—ñ—Ö —á–µ–∫–∞—î! üöÄ","–°–≤—ñ—Ç–ª–æ –ø–µ—Ä–µ–º–∞–≥–∞—î! üí´","–î–æ–±—Ä–æ –ø–æ–≤–µ—Ä—Ç–∞—î—Ç—å—Å—è! ‚ù§Ô∏è",
            "–ù–∞–¥—ñ—è –∑–∞–≤–∂–¥–∏ –∑ –≤–∞–º–∏! üå†","–¢–µ–ø–ª–æ –≤–∑–∏–º–∫—É! üî•","–ß–∞—Ä—ñ–≤–Ω—ñ—Å—Ç—å –†—ñ–∑–¥–≤–∞! üéÅ"
        ];

        let scene, camera, renderer, sphere, prophecyTextMesh, prophecyTextGroup;
        let hands, video;
        let isTouching = false, isCounting = false, prophecyActive = false;
        let touchStartTime = 0, prophecyCount = 0;
        let spherePos = new THREE.Vector3(0, 0, -1.5);

        const elements = {
            loading: document.getElementById('loadingScreen'),
            handGuide: document.getElementById('handGuide'),
            timer: document.getElementById('timer'),
            prophecyCount: document.getElementById('prophecyCount'),
            cameraView: document.getElementById('cameraView'),
            canvas3d: document.getElementById('canvas3d')
        };

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0a2e5c, 0.05);

            camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 100);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ canvas: elements.canvas3d, alpha: true, antialias: devicePixelRatio < 2 });
            renderer.setPixelRatio(Math.min(devicePixelRatio, 1.6));
            renderer.setSize(innerWidth, innerHeight);
            renderer.outputEncoding = THREE.sRGBEncoding;

            const ambient = new THREE.AmbientLight(0xb3e5fc, 0.8);
            scene.add(ambient);
            const point = new THREE.PointLight(0x4fc3f7, 2, 20);
            point.position.set(0, 3, 2);
            scene.add(point);

            createSphere();
            createProphecyText();

            // –°–Ω—ñ–∂–∏–Ω–∫–∏ –Ω–∞ —Ñ–æ–Ω—ñ (–ª–µ–≥–∫—ñ)
            createBackgroundSnow();

            animate();

            setTimeout(() => {
                elements.loading.style.opacity = '0';
                setTimeout(() => elements.loading.style.display = 'none', 600);
            }, 1200);
        }

        function createSphere() {
            const geo = new THREE.SphereGeometry(CONFIG.SPHERE_RADIUS, 48, 48);
            const mat = new THREE.MeshPhongMaterial({
                color: 0xe3f2fd, transparent: true, opacity: 0.96,
                emissive: 0x4fc3f7, emissiveIntensity: 0.7, shininess: 100
            });
            sphere = new THREE.Mesh(geo, mat);
            scene.add(sphere);

            // –ö—ñ–ª—å—Ü–µ –ø—ñ–¥—Å–≤—ñ—Ç–∫–∏
            const ring = new THREE.Mesh(
                new THREE.RingGeometry(CONFIG.SPHERE_RADIUS*1.3, CONFIG.SPHERE_RADIUS*1.5, 32),
                new THREE.MeshBasicMaterial({ color: 0x4fc3f7, transparent: true, opacity: 0.5, side: THREE.DoubleSide })
            );
            ring.rotation.x = -Math.PI/2;
            sphere.add(ring);
            sphere.userData.ring = ring;

            // –í–Ω—É—Ç—Ä—ñ—à–Ω—ñ —Å–Ω—ñ–∂–∏–Ω–∫–∏
            const snowGeo = new THREE.BufferGeometry();
            const count = 80;
            const pos = new Float32Array(count*3);
            for(let i=0; i<count*3; i+=3){
                const r = CONFIG.SPHERE_RADIUS*0.7;
                const theta = Math.random()*Math.PI*2;
                const phi = Math.acos(2*Math.random()-1);
                pos[i]   = r*Math.sin(phi)*Math.cos(theta);
                pos[i+1] = r*Math.sin(phi)*Math.sin(theta);
                pos[i+2] = r*Math.cos(phi);
            }
            snowGeo.setAttribute('position', new THREE.BufferAttribute(pos,3));
            const snow = new THREE.Points(snowGeo, new THREE.PointsMaterial({color:0xffffff,size:0.025,transparent:true,opacity:0.9}));
            sphere.add(snow);
            sphere.userData.snow = snow;
            sphere.userData.origPos = pos.slice();
        }

        function createProphecyText() {
            prophecyTextGroup = new THREE.Group();
            scene.add(prophecyTextGroup);

            const geo = new THREE.PlaneGeometry(3, 0.8);
            const mat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 });
            prophecyTextMesh = new THREE.Mesh(geo, mat);
            prophecyTextGroup.add(prophecyTextMesh);
            prophecyTextGroup.visible = false;
        }

        function updateProphecyText(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            // –ì—Ä–∞–¥—ñ—î–Ω—Ç–Ω–∏–π —Ñ–æ–Ω
            const grad = ctx.createLinearGradient(0,0,0,canvas.height);
            grad.addColorStop(0, 'rgba(255,255,255,0.98)');
            grad.addColorStop(1, 'rgba(220,240,255,0.95)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,canvas.width,canvas.height);

            // –¢–µ–∫—Å—Ç
            ctx.font = 'bold 140px Arial, Helvetica, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // –û–±–≤–æ–¥–∫–∞
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 12;
            ctx.strokeText(text, canvas.width/2, canvas.height/2);

            // –û—Å–Ω–æ–≤–Ω–∏–π –∫–æ–ª—ñ—Ä
            ctx.fillStyle = '#1565c0';
            ctx.fillText(text, canvas.width/2, canvas.height/2);

            // –ë–ª–∏—Å–∫
            ctx.fillStyle = '#4fc3f7';
            ctx.globalAlpha = 0.5;
            ctx.fillText(text, canvas.width/2 - 6, canvas.height/2 - 6);

            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = texture.magFilter = THREE.LinearFilter;

            prophecyTextMesh.material.map = texture;
            prophecyTextMesh.material.opacity = 1;
            prophecyTextMesh.material.needsUpdate = true;
            texture.needsUpdate = true;

            prophecyTextGroup.visible = true;
        }

        function createBackgroundSnow() {
            for(let i=0; i<60; i++){
                const s = document.createElement('div');
                s.innerHTML = '‚ùÑÔ∏è';
                s.style.position = 'fixed';
                s.style.left = Math.random()*100+'vw';
                s.style.top = '-50px';
                s.style.fontSize = (15+Math.random()*20)+'px';
                s.style.opacity = 0.4+Math.random()*0.4;
                s.style.pointerEvents = 'none';
                s.style.animation = `fall ${8+Math.random()*12}s linear infinite`;
                s.style.animationDelay = Math.random()*10+'s';
                document.body.appendChild(s);
            }
            const style = document.createElement('style');
            style.textContent = `@keyframes fall{to{transform:translateY(110vh) rotate(360deg)}}`;
            document.head.appendChild(style);
        }

        function initHands() {
            hands = new Hands({locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({maxNumHands:1, modelComplexity:1, minDetectionConfidence:0.7, minTrackingConfidence:0.7});
            hands.onResults(onResults);

            const cam = new Camera(elements.cameraView, {
                onFrame: async () => await hands.send({image: elements.cameraView}),
                width: 640, height: 480
            });
            cam.start().catch(() => {
                elements.handGuide.innerHTML = '<div style="color:#ff6b6b">‚ö†Ô∏è –ö–∞–º–µ—Ä–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞</div>';
            });
        }

        function onResults(results) {
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                elements.handGuide.style.display = 'block';
                isTouching = false;
                return;
            }

            elements.handGuide.style.display = 'none';
            const lm = results.multiHandLandmarks[0];

            // –¶–µ–Ω—Ç—Ä –¥–æ–ª–æ–Ω—ñ
            const palmX = (lm[0].x + lm[9].x)/2;
            const palmY = (lm[0].y + lm[9].y)/2;
            spherePos.x = (palmX*2-1)*2.8;
            spherePos.y = -(palmY*2-1)*1.6 + 0.5;

            // –í–∫–∞–∑—ñ–≤–Ω–∏–π –ø–∞–ª–µ—Ü—å
            const tip = lm[8];
            const tipX = (tip.x*2-1)*2.8;
            const tipY = -(tip.y*2-1)*1.6 + 0.5;

            const dist = Math.hypot(tipX - spherePos.x, tipY - spherePos.y);

            if (dist < CONFIG.TOUCH_DISTANCE && !prophecyActive) {
                if (!isTouching) {
                    isTouching = true;
                    touchStartTime = Date.now();
                    sphere.userData.ring.material.color.setHex(0xff3366);
                    sphere.userData.ring.material.opacity = 0.9;
                }

                if (Date.now() - touchStartTime >= CONFIG.COUNTDOWN_TIME*1000 && !isCounting) {
                    startCountdown();
                }
            } else if (isTouching) {
                isTouching = false;
                sphere.userData.ring.material.color.setHex(0x4fc3f7);
                sphere.userData.ring.material.opacity = 0.5;
            }
        }

        function startCountdown() {
            if (isCounting || prophecyActive) return;
            isCounting = true; prophecyActive = true;

            elements.timer.style.opacity = 1;
            elements.timer.style.animation = 'pulse 0.6s infinite';
            let sec = CONFIG.COUNTDOWN_TIME;
            elements.timer.textContent = sec;

            sphere.material.emissive.setHex(0xff3366);
            sphere.material.emissiveIntensity = 2;

            const interval = setInterval(() => {
                sec--;
                elements.timer.textContent = sec;
                if (sec <= 0) {
                    clearInterval(interval);
                    elements.timer.style.opacity = 0;
                    showProphecy();
                }
            }, 1000);
        }

        function showProphecy() {
            if (navigator.vibrate) navigator.vibrate([200,100,200]);

            const prophecy = PROPHECIES[Math.floor(Math.random()*PROPHECIES.length)];
            updateProphecyText(prophecy);

            prophecyTextGroup.position.copy(sphere.position);
            prophecyTextGroup.position.y += 0.6;
            prophecyTextGroup.lookAt(camera.position);
            prophecyTextMesh.scale.setScalar(CONFIG.TEXT_SCALE_MULTIPLIER);

            prophecyCount++;
            elements.prophecyCount.textContent = prophecyCount;

            sphere.material.emissive.setHex(0x00ffff);
            sphere.material.emissiveIntensity = 3;

            setTimeout(resetAfterProphecy, CONFIG.PROPHECY_TIME*1000);
        }

        function resetAfterProphecy() {
            prophecyTextMesh.material.opacity = 0;
            prophecyTextMesh.scale.setScalar(1);
            prophecyTextGroup.visible = false;

            sphere.material.emissive.setHex(0x4fc3f7);
            sphere.material.emissiveIntensity = 0.7;

            prophecyActive = isCounting = isTouching = false;
        }

        function animate() {
            requestAnimationFrame(animate);

            if (sphere) {
                sphere.rotation.y += 0.008;
                sphere.position.lerp(spherePos, 0.2);

                // –í–Ω—É—Ç—Ä—ñ—à–Ω—ñ —Å–Ω—ñ–∂–∏–Ω–∫–∏
                if (sphere.userData.snow) {
                    const pos = sphere.userData.snow.geometry.attributes.position.array;
                    const orig = sphere.userData.origPos;
                    const t = Date.now()*0.001;
                    for(let i=0; i<pos.length; i+=3){
                        pos[i]   = orig[i]   + Math.sin(t*1.3 + i)*0.02;
                        pos[i+1] = orig[i+1] + Math.cos(t*0.9 + i)*0.02;
                        pos[i+2] = orig[i+2] + Math.sin(t*0.7 + i)*0.02;
                    }
                    sphere.userData.snow.geometry.attributes.position.needsUpdate = true;
                }

                if (sphere.userData.ring && !isCounting) {
                    const pulse = Math.sin(Date.now()*0.003)*0.15 + 1;
                    sphere.userData.ring.scale.set(pulse, pulse, 1);
                }
            }

            if (prophecyTextGroup?.visible) {
                prophecyTextGroup.position.y = sphere.position.y + 0.6;
                prophecyTextGroup.lookAt(camera.position);
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('load', () => {
            initThreeJS();
            initHands();

            window.addEventListener('resize', () => {
                camera.aspect = innerWidth/innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(innerWidth, innerHeight);
            });
        });
    </script>
</body>
</html>
